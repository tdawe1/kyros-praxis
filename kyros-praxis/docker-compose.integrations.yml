services:
  qdrant:
    image: qdrant/qdrant:latest
    restart: "no"
    ports:
      - "6333:6333" # REST
      - "6334:6334" # gRPC
    environment:
      QDRANT__SERVICE__API_KEY: ${QDRANT_API_KEY:-}
      QDRANT__SERVICE__ENABLE_CORS: "true"
      QDRANT__SERVICE__HTTP_PORT: 6333
      QDRANT__SERVICE__GRPC_PORT: 6334
      QDRANT__STORAGE__STORAGE_PATH: /qdrant/storage
      QDRANT__TELEMETRY_DISABLED: "true"
      QDRANT__LOG__LEVEL: INFO
    volumes:
      - ./qdrant/storage:/qdrant/storage
      - ./qdrant/config/production.yaml:/qdrant/config/production.yaml:ro

  # Filesystem MCP server (scoped to a specific host path)
  mcp_filesystem:
    stdin_open: true
    tty: true
    image: ${FS_NODE_IMAGE:-node:20-alpine}
    restart: "no"
    profiles: ["fs"]
    working_dir: /workspace
    command:
      ["npx", "-y", "@modelcontextprotocol/server-filesystem", "/workspace"]
    volumes:
      - ${FS_PATH:-.}:/workspace:${FS_MODE:-ro}
    environment:
      FS_ALLOW_GLOBS: ${FS_ALLOW_GLOBS:-**/*}

  # Memory MCP server (vector memory; defaults to Qdrant backend)
  mcp_memory:
    stdin_open: true
    tty: true
    image: ${MEMORY_NODE_IMAGE:-node:20-alpine}
    restart: "no"
    profiles: ["memory"]
    environment:
      QDRANT_URL: ${QDRANT_URL:-http://qdrant:6333}
      QDRANT_API_KEY: ${QDRANT_API_KEY:-}
      COLLECTION: ${MEMORY_COLLECTION:-kyros_agents}
    working_dir: /app
    command: ["npx", "-y", "@modelcontextprotocol/server-memory"]
    depends_on:
      - qdrant

  # Context7 MCP server
  context7:
    image: ${CONTEXT7_NODE_IMAGE:-node:20-alpine}
    restart: "no"
    profiles: ["context7"]
    working_dir: /app
    command: ["npx", "-y", "@upstash/context7-mcp"]
    environment:
      DEFAULT_MINIMUM_TOKENS: ${CONTEXT7_DEFAULT_MINIMUM_TOKENS:-256}
      CONTEXT7_API_TOKEN: ${CONTEXT7_API_TOKEN:-}

  # GitHub issue/PR MCP bridge (headless). Provide an image that exposes MCP tools
  # over WS or stdio. If stdio-only, you may not need to expose a port.
  mcp_github:
    stdin_open: true
    tty: true
    image: ${GITHUB_MCP_IMAGE:-ghcr.io/github/github-mcp-server}
    restart: "no"
    profiles: ["github"]
    environment:
      GITHUB_PERSONAL_ACCESS_TOKEN: ${GITHUB_PERSONAL_ACCESS_TOKEN:?set a token with repo scope}
      GITHUB_TOOLSETS: ${GITHUB_TOOLSETS:-repos,issues,pull_requests,code_security}
      GITHUB_READ_ONLY: ${GITHUB_READ_ONLY:-}
    # Example WS port (if your bridge exposes a socket)
    # ports:
    #   - "8787:8787"

  # Headless browser (Puppeteer via CDP). Also works with Playwright over CDP.
  mcp_puppeteer:
    stdin_open: true
    tty: true
    image: ${PUPPETEER_MCP_IMAGE:-node:20-alpine}
    restart: "no"
    profiles: ["puppeteer"]
    working_dir: /app
    command: ["npx", "-y", "@modelcontextprotocol/server-puppeteer"]
    environment:
      BROWSERLESS_TOKEN: ${BROWSERLESS_TOKEN:-}

  # Playwright runner (for CI/E2E). Not a service API by default; used to exec tests.
  # You can `docker compose run --rm playwright npx playwright test`.
  mcp_playwright:
    image: ${PLAYWRIGHT_IMAGE:-mcr.microsoft.com/playwright:v1.45.0-jammy}
    profiles: ["playwright"]
    shm_size: "1gb"
    working_dir: /workspace
    command: ["bash", "-lc", "npx -y @playwright/mcp@latest --browser=chromium --headless --viewport-size=1280,800 --no-sandbox"]
    volumes:
      - ./:/workspace:ro

  # Redis MCP server (+ optional local Redis instance)
  mcp_redis:
    image: ${REDIS_MCP_NODE_IMAGE:-node:20-alpine}
    restart: "no"
    profiles: ["redis"]
    working_dir: /app
    command: ["sh", "-lc", "npx -y @modelcontextprotocol/server-redis ${REDIS_URL:-redis://redis:6379}"]
    environment:
      # @modelcontextprotocol/server-redis expects discrete settings; REDIS_URL is ignored
      REDIS_HOST: ${REDIS_HOST:-redis}
      REDIS_PORT: ${REDIS_PORT:-6379}
      REDIS_DB: ${REDIS_DB:-0}
      REDIS_PASSWORD: ${REDIS_PASSWORD:-}
    depends_on:
      - redis

  redis:
    image: ${REDIS_IMAGE:-redis:7-alpine}
    restart: "no"
    profiles: ["redis"]
    ports:
      - "6379:6379"
    command: ["redis-server", "--appendonly", "yes"]

  # Zen MCP server (official; runs via uvx inside container)
  mcp_zen:
    stdin_open: true
    tty: true
    build:
      context: ./integrations/zen-mcp
      dockerfile: Dockerfile
    image: ${ZEN_MCP_IMAGE:-local/zen-mcp:latest}
    restart: "no"
    profiles: ["zen"]
    environment:
      OPENAI_BASE_URL: ${OPENAI_BASE_URL:-https://api.z.ai/api/coding/paas/v4}
      OPENAI_API_BASE: ${OPENAI_API_BASE:-${OPENAI_BASE_URL:-https://api.z.ai/api/coding/paas/v4}}
      CUSTOM_API_URL: ${CUSTOM_API_URL:-${OPENAI_BASE_URL:-https://api.z.ai/api/coding/paas/v4}}
      CUSTOM_API_KEY: ${CUSTOM_API_KEY:-${OPENAI_API_KEY:-}}
      OPENAI_API_KEY: ${OPENAI_API_KEY:-}
      GEMINI_API_KEY: ${GEMINI_API_KEY:-}
      OPENROUTER_API_KEY: ${OPENROUTER_API_KEY:-}

  # Notion MCP server
  mcp_notion:
    stdin_open: true
    tty: true
    image: ${NOTION_MCP_IMAGE:-node:20-alpine}
    restart: "no"
    profiles: ["notion"]
    working_dir: /app
    command: ["npx", "-y", "@notionhq/notion-mcp-server"]
    environment:
      OPENAPI_MCP_HEADERS: ${OPENAPI_MCP_HEADERS:-}

  # Sequential Thinking MCP server
  mcp_sequentialthinking:
    stdin_open: true
    tty: true
    image: ${SEQ_MCP_IMAGE:-node:20-alpine}
    restart: "no"
    profiles: ["seq"]
    working_dir: /app
    command: ["npx", "-y", "@modelcontextprotocol/server-sequential-thinking"]

  # Composer Trade MCP server (Python uvx)
  mcp_composer_trade:
    stdin_open: true
    tty: true
    image: ${UV_IMAGE:-ghcr.io/astral-sh/uv:latest}
    restart: "no"
    profiles: ["composer"]
    environment:
      COMPOSER_API_KEY: ${COMPOSER_API_KEY:-}
      COMPOSER_SECRET_KEY: ${COMPOSER_SECRET_KEY:-}
    command:
      [
        "uvx",
        "composer-trade-mcp==0.1.4",
        "--hash",
        "sha256:37d8fcfd6ddc9c8155633f755159f3fcb1a63e7acc2a32513613341a851c84e2",
      ]

  # ExaSearch MCP server
  mcp_exasearch:
    stdin_open: true
    tty: true
    image: ${EXASEARCH_MCP_IMAGE:-node:20-alpine}
    restart: "no"
    profiles: ["exasearch"]
    working_dir: /app
    environment:
      EXA_API_KEY: ${EXA_API_KEY:-}
      # Optional: if the server supports WS, these are common patterns
      EXASEARCH_MCP_PORT: ${EXASEARCH_MCP_PORT:-8788}
    # Use the official remote Exa MCP via mcp-remote and your EXA_API_KEY.
    # Run this service interactively via scripts/mcp-run.sh to attach stdio.
    # Avoid single quotes so ${EXA_API_KEY} is expanded by the shell
    command: ["sh", "-lc", "npx -y mcp-remote \"https://mcp.exa.ai/mcp?exaApiKey=${EXA_API_KEY}\""]
    # If your Exa MCP server exposes a WebSocket port, uncomment the line below
    # and ensure the command starts a WS server bound to 0.0.0.0:EXASEARCH_MCP_PORT.
    # ports:
    #   - "${EXASEARCH_MCP_PORT:-8788}:8788"

  # Railway MCP server
  mcp_railway:
    stdin_open: true
    tty: true
    image: ${RAILWAY_NODE_IMAGE:-node:20-alpine}
    restart: "no"
    profiles: ["railway"]
    working_dir: /app
    command: ["sh", "-lc", "npx -y ${RAILWAY_MCP_PACKAGE:-@railway/mcp-server}"]
    environment:
      RAILWAY_TOKEN: ${RAILWAY_TOKEN:-}

  # Vercel MCP server
  mcp_vercel:
    stdin_open: true
    tty: true
    image: ${VERCEL_NODE_IMAGE:-node:20-alpine}
    restart: "no"
    profiles: ["vercel"]
    working_dir: /app
    command: ["sh", "-lc", "npx -y ${VERCEL_MCP_PACKAGE:-mcp-vercel}"]
    environment:
      VERCEL_TOKEN: ${VERCEL_TOKEN:-}

  # CodeRabbit MCP server
  mcp_coderabbit:
    stdin_open: true
    tty: true
    image: ${CODERABBIT_NODE_IMAGE:-node:20-alpine}
    restart: "no"
    profiles: ["coderabbit"]
    working_dir: /app
    command: ["sh", "-lc", "npx -y ${CODERABBIT_MCP_PACKAGE:-coderabbit-mcp}"]
    environment:
      CODERABBIT_API_KEY: ${CODERABBIT_API_KEY:-}

  # Kyros core services (feature-complete stack)
  kyros_orchestrator:
    build:
      context: ./services/orchestrator
      dockerfile: Dockerfile
    env_file:
      - ./services/orchestrator/.env.example
    environment:
      DATABASE_URL: ${ORCH_DATABASE_URL:-sqlite:///orchestrator.db}
      REDIS_URL: ${ORCH_REDIS_URL:-redis://redis:6379}
      SECRET_KEY: ${ORCH_SECRET_KEY:-dev-secret}
      QDRANT_URL: ${QDRANT_URL:-http://qdrant:6333}
      QDRANT_API_KEY: ${QDRANT_API_KEY:-}
    depends_on:
      - qdrant
    ports:
      - "8000:8000"
    profiles: ["kyros"]

  kyros_registry:
    build:
      context: ./packages/service-registry
      dockerfile: Dockerfile
    env_file:
      - ./packages/service-registry/.env.example
    environment:
      # Override to local sqlite and internal redis for a self-contained dev run
      DATABASE_URL: ${REGISTRY_DATABASE_URL:-sqlite:///services.db}
      REDIS_URL: ${REGISTRY_REDIS_URL:-redis://redis:6379}
    ports:
      - "9000:9000"
    profiles: ["kyros"]

  kyros_daemon:
    build:
      context: .
      dockerfile: services/terminal-daemon/Dockerfile
    env_file:
      - ./services/terminal-daemon/.env.example
    ports:
      - "8080:8080"
    profiles: ["kyros"]

  # Kyros MCP server (bridges Kyros APIs/Registry/Daemon/Memory to MCP tools)
  mcp_kyros:
    stdin_open: true
    tty: true
    build:
      context: ./integrations/kyros-mcp
      dockerfile: Dockerfile
    image: ${KYROS_MCP_IMAGE:-local/kyros-mcp:latest}
    restart: "no"
    profiles: ["kyros-mcp"]
    environment:
      KYROS_API_BASE: ${KYROS_API_BASE:-http://kyros_orchestrator:8000}
      KYROS_REGISTRY_URL: ${KYROS_REGISTRY_URL:-http://kyros_registry:9000}
      KYROS_DAEMON_URL: ${KYROS_DAEMON_URL:-ws://kyros_daemon:8080/ws}
      QDRANT_URL: ${QDRANT_URL:-http://qdrant:6333}
      QDRANT_API_KEY: ${QDRANT_API_KEY:-}
      KYROS_MCP_API_KEY: ${KYROS_MCP_API_KEY:-}
      KYROS_MCP_TOOLS: ${KYROS_MCP_TOOLS:-runs,registry,memory,terminal}
    depends_on:
      - kyros_orchestrator
      - kyros_registry
      - kyros_daemon
      - qdrant

  # Fireproof MCP server (build and run node project)
  mcp_fireproof:
    stdin_open: true
    tty: true
    build:
      context: ./integrations/fireproof-mcp
      dockerfile: Dockerfile
    image: ${FIREPROOF_MCP_IMAGE:-local/fireproof-mcp:latest}
    restart: "no"
    profiles: ["fireproof"]

  # Zen Tools MCP (our local tools wrapper around sessions/agents)
  mcp_zen_tools:
    stdin_open: true
    tty: true
    image: ${ZEN_TOOLS_PY_IMAGE:-python:3.11-slim}
    restart: "no"
    profiles: ["zen-tools"]
    working_dir: /workspace
    command: ["python", "-u", "integrations/zen-mcp/main.py"]
    volumes:
      - ./:/workspace
    environment:
      ZEN_ROOT: /workspace/zen
  # Kyros Collab MCP server (stdio JSON-RPC over process). Provided for reference; prefer spawning locally.
  mcp_kyros_collab:
    stdin_open: true
    tty: true
    image: ${PY_IMAGE:-python:3.11-alpine}
    restart: "no"
    profiles: ["kyros-collab"]
    working_dir: /workspace
    command:
      ["python", "-u", "integrations/kyros-collab-mcp/main.py"]
    volumes:
      - ./:/workspace
    environment:
      COLLAB_ROOT: /workspace/collaboration

networks:
  default:
    name: kyros-integrations
    external: true
